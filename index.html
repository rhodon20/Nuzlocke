<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Pokemon Rogue - Kanto Edition</title>
  <style>
    :root{
      --ui-bg: #0b1020;
      --ui-panel: #111938;
      --ui-panel-2:#0f1631;
      --ui-accent:#00c6d7;
      --ui-accent-2:#ffd54a;
      --ui-danger:#ff6b6b;
      --ui-warning:#ff9800;
      --ui-ok:#4caf50;
      --ui-text:#e8ecff;
      --ui-muted:#9aa3c7;
      --xp-bar: #2196f3;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: #060814;
      color: var(--ui-text);
      margin: 0;
      padding: 10px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    #game-container {
      width: 100%;
      max-width: 500px;
      background: linear-gradient(180deg, #0b1020 0%, #070b18 100%);
      padding: 12px;
      border-radius: 16px;
      box-shadow:
        0 0 0 2px rgba(0,198,215,.25),
        0 20px 50px rgba(0,0,0,.7);
      border: 1px solid rgba(0,198,215,.35);
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    h1 {
      color: var(--ui-accent-2);
      text-align: center;
      margin: 0;
      font-size: 1.4rem;
      font-weight: 900;
      letter-spacing: .5px;
      text-shadow: 0 2px 0 #000;
      border-bottom: 2px solid rgba(255,213,74,.2);
      padding-bottom: 8px;
    }
    .hidden-title { display: none; }

    /* ======= Battle Scene ======= */
    #battle-scene{
      background-color: #333;
      border-radius: 12px;
      height: 280px;
      position: relative;
      overflow: hidden;
      border: 2px solid #000;
      box-shadow: inset 0 0 40px rgba(0,0,0,.6);
      transition: background 0.5s ease;
    }

    /* Fondos Din√°micos */
    .bg-forest { background: linear-gradient(180deg, #81c784 0%, #2e7d32 30%, #1b5e20 100%); }
    .bg-cave { background: linear-gradient(180deg, #795548 0%, #3e2723 40%, #1a100e 100%); }
    .bg-ocean { background: linear-gradient(180deg, #4fc3f7 0%, #0288d1 40%, #01579b 100%); }
    .bg-night { background: linear-gradient(180deg, #303f9f 0%, #1a237e 40%, #000000 100%); }
    .bg-volcano { background: linear-gradient(180deg, #ff8a65 0%, #d84315 40%, #3e2723 100%); }
    
    @keyframes screen-shake {
      0% { transform: translate(0, 0); }
      20% { transform: translate(-4px, 4px); }
      40% { transform: translate(4px, -4px); }
      60% { transform: translate(-4px, -4px); }
      80% { transform: translate(4px, 4px); }
      100% { transform: translate(0, 0); }
    }
    .shake-screen { animation: screen-shake 0.4s ease-out; }

    /* ZONAS DE COMBATE */
    .combatant-zone {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      z-index: 10;
    }

    #zone-opponent {
      top: 4%; 
      right: 8%;
      width: 120px;
      height: 120px;
    }

    #zone-player {
      bottom: 8%;
      left: 8%;
      width: 150px; 
      height: 150px;
      z-index: 20; 
    }

    .battle-shadow {
      width: 80%;
      height: 18px;
      background: rgba(0,0,0,0.4);
      border-radius: 50%;
      transform: scaleY(0.5);
      filter: blur(3px);
      margin-top: -8px; 
      z-index: 1;
    }

    /* Sprites */
    .sprite-container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      position: relative;
      z-index: 5;
    }

    .sprite-img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      image-rendering: pixelated;
      filter: drop-shadow(0 4px 4px rgba(0,0,0,0.4));
      transition: filter 0.2s;
    }

    @keyframes idle-anim {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-4px); }
    }
    .anim-idle .sprite-img { animation: idle-anim 2.5s infinite ease-in-out; }

    @keyframes attack-push-right {
      0% { transform: translateX(0); }
      30% { transform: translateX(-10px) rotate(-5deg); }
      50% { transform: translateX(40px); }
      100% { transform: translateX(0); }
    }
    @keyframes attack-push-left {
      0% { transform: translateX(0); }
      30% { transform: translateX(10px) rotate(5deg); }
      50% { transform: translateX(-40px); }
      100% { transform: translateX(0); }
    }
    .anim-attack-player .sprite-img { animation: attack-push-right 0.3s ease-in-out; }
    .anim-attack-opponent .sprite-img { animation: attack-push-left 0.3s ease-in-out; }

    @keyframes damage-blink {
      0%, 100% { opacity: 1; filter: brightness(1) sepia(0) saturate(1); }
      20% { opacity: 0.2; filter: brightness(10) sepia(1) hue-rotate(-50deg); }
      40% { opacity: 1; filter: brightness(1); }
      60% { opacity: 0.2; filter: brightness(10) sepia(1) hue-rotate(-50deg); }
      80% { opacity: 1; filter: brightness(1); }
    }
    .anim-damage .sprite-img { animation: damage-blink 0.6s linear; }

    /* UI Stats Boxes */
    .stats-box {
      position: absolute;
      background: rgba(17, 25, 56, 0.95);
      border: 1px solid rgba(255,255,255,0.4);
      border-radius: 6px;
      padding: 4px 8px;
      width: 120px;
      z-index: 30;
      box-shadow: 0 4px 10px rgba(0,0,0,0.6);
      pointer-events: none;
    }
    #opponent-box { left: 12px; top: 12px; }
    #player-box { right: 12px; bottom: 30px; }

    .poke-name { 
      font-weight: 800; font-size: 0.8rem; margin-bottom: 2px; 
      display: flex; justify-content: space-between; align-items:center;
    }
    .poke-lvl { color: var(--ui-accent-2); font-size: 0.8rem; }
    
    .hp-container {
      background: #222;
      height: 6px;
      border-radius: 4px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.2);
      position: relative;
    }
    .hp-fill {
      height: 100%;
      background: var(--ui-ok);
      width: 100%;
      transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1), background 0.3s;
    }
    .hp-text { font-size: 0.7rem; text-align: right; margin-top: 1px; font-weight: bold; text-shadow: 0 1px 1px black; }
    
    .xp-container {
      margin-top: 2px;
      background: #111;
      height: 3px;
      border-radius: 2px;
      overflow: hidden;
    }
    .xp-fill {
      height: 100%;
      background: var(--xp-bar);
      width: 0%;
      transition: width 0.4s;
    }

    /* Status Tags */
    .status-tag {
      font-size: 0.65rem;
      padding: 1px 3px;
      border-radius: 3px;
      margin-right: 4px;
      font-weight: bold;
      color: #fff;
      display: inline-block;
    }
    .status-BRN { background: #ff5722; }
    .status-PSN { background: #9c27b0; }
    .status-PAR { background: #ffeb3b; color: #000; }
    .status-SLP { background: #90a4ae; }
    .status-FRZ { background: #03a9f4; }

    /* PROYECTILES Y VFX */
    .projectile {
      position: absolute;
      width: 32px;
      height: 32px;
      z-index: 25;
      pointer-events: none;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      transition: top 0.4s linear, left 0.4s linear;
    }
    .proj-fire { background: radial-gradient(circle, #ffeb3b 20%, #f44336 70%); border-radius: 50%; box-shadow: 0 0 10px orange; }
    .proj-water { background: radial-gradient(circle at 30% 30%, #fff, #2196f3); border-radius: 50% 50% 50% 0; transform: rotate(-45deg); box-shadow: 0 0 10px #03a9f4; }
    .proj-grass { background-color: #4caf50; clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); }
    .proj-electric { background: #ffeb3b; clip-path: polygon(25% 0%, 100% 0%, 75% 100%, 0% 100%); box-shadow: 0 0 15px yellow; }
    .proj-rock { background: #795548; border-radius: 50%; border: 2px solid #3e2723; }
    .proj-normal { background: #fff; border-radius: 50%; opacity: 0.8; }
    .proj-ghost { background: #9c27b0; border-radius: 50%; box-shadow: 0 0 15px #e1bee7; opacity: 0.7; }
    
    .vfx-particle {
      position: absolute;
      pointer-events: none;
      font-size: 20px;
      z-index: 26;
      animation: impact-explode 0.6s ease-out forwards;
    }
    @keyframes impact-explode {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
      100% { transform: translate(var(--tx), var(--ty)) scale(1.5) rotate(var(--rot)); opacity: 0; }
    }

    /* ======= Logs & Controls ======= */
    #combat-log {
      height: 60px;
      background: rgba(0,0,0,0.4);
      border: 1px solid var(--ui-accent);
      padding: 8px;
      overflow-y: auto;
      border-radius: 8px;
      font-size: 0.85rem;
      line-height: 1.3;
      color: #fff;
    }

    #controls-area {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
    .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; }

    button {
      background: var(--ui-panel-2);
      border: 1px solid rgba(255,255,255,0.1);
      color: var(--ui-text);
      padding: 10px 4px;
      border-radius: 6px;
      font-weight: 700;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.1s;
      text-transform: capitalize;
      position: relative;
      overflow: hidden;
      touch-action: manipulation;
    }
    button:active:not(:disabled) { transform: translateY(2px); }
    button:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }

    .btn-move { background: #232944; border-bottom: 3px solid rgba(0,0,0,0.3); }
    .btn-move:hover:not(:disabled) { filter: brightness(1.2); }
    
    .type-Fuego { background: #d84315; color: #fff; }
    .type-Agua { background: #1565c0; color: #fff; }
    .type-Planta { background: #2e7d32; color: #fff; }
    .type-El√©ctrico { background: #f9a825; color: #000; }
    .type-Normal { background: #78909c; color: #fff; }
    .type-Volador { background: #7e57c2; color: #fff; }
    .type-Bicho { background: #827717; color: #fff; }
    .type-Veneno { background: #6a1b9a; color: #fff; }
    .type-Tierra { background: #795548; color: #fff; }
    .type-Roca { background: #5d4037; color: #fff; }
    .type-Lucha { background: #b71c1c; color: #fff; }
    .type-Ps√≠quico { background: #c2185b; color: #fff; }
    .type-Fantasma { background: #4527a0; color: #fff; }
    .type-Hielo { background: #00acc1; color: #fff; }
    .type-Drag√≥n { background: #311b92; color: #fff; }
    /* Nuevos en 2¬™ Generaci√≥n */
    .type-Acero { background: #607d8b; color: #fff; }
    .type-Siniestro { background: #212121; color: #fff; }
    
    .btn-action { background: #37474f; color: #eceff1; }
    .btn-capture { background: #c62828; }
    .btn-potion { background: #2e7d32; }
    .btn-switch { background: #f57f17; color: black; }
    
    #start-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 5px;
    }
    #btn-normal { background: linear-gradient(135deg, var(--ui-accent-2), var(--ui-warning)); color: #000; padding: 14px; font-size:1.1rem; border:none; }
    #btn-nuzlocke { background: linear-gradient(135deg, #7b1fa2, #4a148c); color: #fff; padding: 14px; font-size:1.1rem; border:none; }

    #team-bar {
      display: flex;
      justify-content: space-between;
      background: rgba(0,0,0,0.3);
      padding: 5px 10px;
      border-radius: 20px;
      font-size: 0.8rem;
    }

    /* Generic Modal Overlay */
    .modal-overlay {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(11, 16, 32, 0.95);
      z-index: 50;
      display: none;
      flex-direction: column;
      padding: 10px;
      box-sizing: border-box;
      justify-content: center;
    }
    
    .modal-title { text-align:center; margin:0 0 10px 0; color: var(--ui-accent); }
    .modal-list { flex:1; overflow-y:auto; margin-bottom: 10px; }
    
    .modal-card {
      background: var(--ui-panel);
      margin-bottom: 8px;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }
    .modal-card:hover { border-color: var(--ui-accent); }
    .modal-card.selected { border-color: var(--ui-accent-2); background: #222; }
    .modal-card.fainted { opacity: 0.6; filter: grayscale(1); cursor: not-allowed; }
    
    .mode-badge {
      position: absolute;
      top: 5px; left: 5px;
      font-size: 0.7rem;
      background: #333;
      padding: 2px 6px;
      border-radius: 4px;
      opacity: 0.7;
    }
  </style>
  <link rel="stylesheet" href="index.css">
</head>

<body onload="initGame()">

  <div id="game-container">
    <div id="mode-display" class="mode-badge"></div>
    <h1 id="game-title">‚öîÔ∏è PokeRogue Kanto üí•</h1>

    <div id="battle-scene" class="bg-forest">
      <div id="vfx-layer" style="position:absolute; inset:0; pointer-events:none; z-index:40;"></div>

      <div class="stats-box" id="opponent-box"></div>
      
      <div class="combatant-zone" id="zone-opponent">
        <div class="sprite-container anim-idle" id="opponent-sprite-slot"></div>
        <div class="battle-shadow"></div>
      </div>

      <div class="combatant-zone" id="zone-player">
        <div class="sprite-container anim-idle" id="player-sprite-slot"></div>
        <div class="battle-shadow"></div>
      </div>

      <div class="stats-box" id="player-box"></div>
    </div>

    <div id="team-bar">
      <span>üèÖ x<b id="badges-val">0</b></span>
      <span>üé± x<b id="balls-val">0</b></span>
      <span>üíä x<b id="pots-val">0</b></span>
      <span>üèÜ Racha: <b id="streak-val">0</b></span>
    </div>

    <div id="combat-log">Bienvenido a Kanto Rogue.</div>

    <div id="controls-area">
      <div id="move-controls" class="grid-2"></div>
      
      <div id="utility-controls" class="grid-3">
        <button class="btn-action btn-potion" onclick="usePotion()" id="btn-potion">Poci√≥n</button>
        <button class="btn-action btn-capture" onclick="attemptCapture()" id="btn-capture">Capturar</button>
        <button class="btn-action btn-switch" onclick="openSwitchMenu()" id="btn-switch">Cambiar</button>
      </div>

      <div class="grid-2">
        <button class="btn-action" onclick="saveGame()">üíæ Guardar</button>
        <button class="btn-action" onclick="loadGame()" id="btn-load" disabled>üìÇ Cargar</button>
      </div>
    </div>

    <div id="start-buttons">
      <button id="btn-normal" onclick="startGame('normal')">Modo Normal</button>
      <button id="btn-nuzlocke" onclick="startGame('nuzlocke')">‚ò†Ô∏è Modo Nuzlocke</button>
    </div>

    <div id="switch-overlay" class="modal-overlay">
      <h3 class="modal-title">Elige un Pok√©mon</h3>
      <div id="switch-list" class="modal-list"></div>
      <button class="btn-action" onclick="closeSwitchMenu()">Cancelar</button>
    </div>

    <div id="move-overlay" class="modal-overlay">
      <h3 class="modal-title">¬°L√≠mite de movimientos!</h3>
      <p style="text-align:center; font-size:0.9rem; margin-bottom:10px;">Elige un movimiento para olvidar:</p>
      <div id="move-list" class="modal-list"></div>
      <button class="btn-action" id="btn-cancel-learn">No aprender</button>
    </div>

    <div id="party-full-overlay" class="modal-overlay">
      <h3 class="modal-title">¬°Equipo Completo!</h3>
      <p style="text-align:center; font-size:0.9rem; margin-bottom:10px;">Selecciona un Pok√©mon para <b>liberar</b> y hacer sitio al nuevo, o libera al capturado.</p>
      <div id="party-full-list" class="modal-list"></div>
      <button class="btn-action btn-capture" id="btn-release-new">Liberar al Nuevo</button>
    </div>
  </div>

<script>
/* =========================================================
   DATABASE & CONFIG
========================================================= */
const CONSTANTS = {
  START_BALLS: 6,
  START_POTS: 6,
  MAX_BALLS: 100,
  MAX_POTS: 50,
  HEAL_STREAK: 3,
  XP_MULT: 4.5, 
  SHINY_CHANCE: 0.005,
  MAX_TEAM: 6
};

const SLUG_MAP = {
  "Nidoran-F": "nidoran-f", "Nidoran-M": "nidoran-m", "Mr. Mime": "mr-mime", "Farfetch'd": "farfetchd"
};
</script>
<script src="moveset.js"></script>
<script src="pok_catalog.js"></script>
<script src="evolutions.js"></script>
<script src="types.js"></script>

<script>
/* =========================================================
   GAME STATE
========================================================= */
let state = {
  team: [],
  inventory: { balls: 0, potions: 0 },
  streak: 0,
  badges: 0,
  activeIdx: 0,
  gameMode: 'normal' // 'normal' or 'nuzlocke'
};
let opponent = null;
let turnLock = false;

/* =========================================================
   CLASSES
========================================================= */
class Pokemon {
  constructor(name, level, isNuzlocke = false) {
    const data = POKEMON_SPECIES[name];
    this.name = name;
    this.level = level;
    this.types = data.type;
    this.xp = 0;
    this.xpToNext = level * 60 + 100;
    this.isShiny = Math.random() < CONSTANTS.SHINY_CHANCE;
    this.status = null; // 'BRN', 'PSN', 'PAR', 'SLP', 'FRZ'
    
    // Stats Calculator 
    this.bonusMultiplier = 1.0; // Para el evento de la 8¬™ medalla
    this.baseStats = {
      hp: data.hp, atk: data.atk, def: data.def, 
      spa: data.sp_atk, spd: data.sp_def, spe: data.speed
    };
    
    // In-Battle Stat Stages (-6 to +6)
    this.stages = { atk:0, def:0, spa:0, spd:0, spe:0 };

    this.recalcStats();
    this.hp = this.maxHp;

    // Move Logic based on Mode
    if (isNuzlocke) {
      // Random moves from global pool
      const allMoves = Object.keys(MOVES);
      this.moves = [];
      const numMoves = Math.min(4, Math.max(1, Math.floor(level / 5)));
      for(let i=0; i<numMoves; i++) {
        const rnd = allMoves[Math.floor(Math.random() * allMoves.length)];
        if(!this.moves.includes(rnd)) this.moves.push(rnd);
      }
    } else {
      this.moves = (data.moves || ['Tackle']).filter(mName => MOVES[mName]);
      if (this.moves.length === 0) this.moves = ['Tackle'];
    }
  }

  recalcStats() {
    const mult = this.bonusMultiplier;
    // HP Formula Simplificada
    this.maxHp = Math.floor(0.01 * (2 * this.baseStats.hp * mult) * this.level) + this.level + 10;
    // Base Stats Logic
    this.atk = Math.floor(0.01 * (2 * this.baseStats.atk * mult) * this.level) + 5;
    this.def = Math.floor(0.01 * (2 * this.baseStats.def * mult) * this.level) + 5;
    this.spa = Math.floor(0.01 * (2 * this.baseStats.spa * mult) * this.level) + 5;
    this.spd = Math.floor(0.01 * (2 * this.baseStats.spd * mult) * this.level) + 5;
    this.spe = Math.floor(0.01 * (2 * this.baseStats.spe * mult) * this.level) + 5;
  }

  // Get Stat with Stages and Status modifiers (In-Battle)
  getStat(statName) {
    let base = this[statName]; // this.atk, this.spe, etc.
    let stage = this.stages[statName] || 0;
    
    // Stage Multiplier
    let multiplier = 1.0;
    if (stage >= 0) multiplier = (2 + stage) / 2;
    else multiplier = 2 / (2 + Math.abs(stage));
    
    let finalVal = Math.floor(base * multiplier);

    // Status Modifiers
    if (statName === 'spe' && this.status === 'PAR') finalVal = Math.floor(finalVal * 0.5); // Paralysis cuts speed

    return Math.max(1, finalVal);
  }

  resetStages() {
    this.stages = { atk:0, def:0, spa:0, spd:0, spe:0 };
  }
}

/* =========================================================
   HELPERS & VFX
========================================================= */
const $ = id => document.getElementById(id);
const wait = ms => new Promise(r => setTimeout(r, ms));

function log(msg) {
  const div = document.createElement('div');
  div.innerHTML = msg;
  div.style.marginBottom = '4px';
  $('combat-log').prepend(div);
  if ($('combat-log').children.length > 20) $('combat-log').lastChild.remove();
}

function getEffectIcon(type) {
  const icons = {
    'Fuego': 'üî•', 'Agua': 'üíß', 'Planta': 'üçÉ', 'El√©ctrico': '‚ö°', 
    'Roca': 'ü™®', 'Tierra': 'üèúÔ∏è', 'Volador': 'üå™Ô∏è', 'Ps√≠quico': 'üîÆ',
    'Fantasma': 'üëª', 'Hielo': '‚ùÑÔ∏è', 'Veneno': '‚ò†Ô∏è', 'Lucha': 'ü•ä',
    'Bicho': 'ü¶ü', 'Drag√≥n': 'üêâ', 'Normal': 'üí•'
  };
  return icons[type] || 'üí•';
}

function getProjectileClass(type) {
  const map = {
    'Fuego': 'proj-fire', 'Agua': 'proj-water', 'Planta': 'proj-grass', 
    'El√©ctrico': 'proj-electric', 'Roca': 'proj-rock', 'Fantasma': 'proj-ghost'
  };
  return map[type] || 'proj-normal';
}

async function shootProjectile(type, fromId, toId) {
  const fromEl = $(fromId);
  const toEl = $(toId);
  const layer = $('vfx-layer');
  if (!fromEl || !toEl) return;

  const r1 = fromEl.getBoundingClientRect();
  const r2 = toEl.getBoundingClientRect();
  const parent = layer.getBoundingClientRect();

  const startX = r1.left - parent.left + r1.width/2;
  const startY = r1.top - parent.top + r1.height/2;
  const endX = r2.left - parent.left + r2.width/2;
  const endY = r2.top - parent.top + r2.height/2;

  const p = document.createElement('div');
  p.className = `projectile ${getProjectileClass(type)}`;
  p.style.left = (startX - 16) + 'px';
  p.style.top = (startY - 16) + 'px';
  
  layer.appendChild(p);
  p.getBoundingClientRect(); 
  
  p.style.left = (endX - 16) + 'px';
  p.style.top = (endY - 16) + 'px';
  
  await wait(400); 
  p.remove();
}

function spawnParticles(type, targetEl) {
  const rect = targetEl.getBoundingClientRect();
  const parent = $('vfx-layer').getBoundingClientRect();
  const centerX = rect.left - parent.left + rect.width / 2;
  const centerY = rect.top - parent.top + rect.height / 2;
  const icon = getEffectIcon(type);

  for(let i=0; i<6; i++) {
    const p = document.createElement('div');
    p.classList.add('vfx-particle');
    p.textContent = icon;
    p.style.left = centerX + 'px';
    p.style.top = centerY + 'px';
    
    const angle = Math.random() * 360;
    const dist = 30 + Math.random() * 40;
    const tx = Math.cos(angle * Math.PI / 180) * dist + 'px';
    const ty = Math.sin(angle * Math.PI / 180) * dist + 'px';
    const rot = (Math.random() * 360) + 'deg';
    
    p.style.setProperty('--tx', tx);
    p.style.setProperty('--ty', ty);
    p.style.setProperty('--rot', rot);

    $('vfx-layer').appendChild(p);
    setTimeout(() => p.remove(), 600);
  }
}

async function animateAttack(attackerSlotId, type) {
  const el = $(attackerSlotId);
  const isPlayer = attackerSlotId.includes('player');
  const animClass = isPlayer ? 'anim-attack-player' : 'anim-attack-opponent';
  
  el.classList.remove('anim-idle');
  el.classList.add(animClass);
  await wait(300);
  el.classList.remove(animClass);
  el.classList.add('anim-idle');
}

async function animateDamage(victimSlotId) {
  const el = $(victimSlotId);
  el.classList.add('anim-damage');
  $('battle-scene').classList.add('shake-screen');
  await wait(500);
  el.classList.remove('anim-damage');
  $('battle-scene').classList.remove('shake-screen');
}

// 1. A√±ade esta funci√≥n auxiliar para calcular el Tier seg√∫n el Nivel
function getTierFromLevel(level) {
  if (level <= 15) return 1;
  if (level <= 30) return 2;
  if (level <= 45) return 3;
  if (level <= 60) return 4;
  return 5; // Nivel 61 en adelante
}

/* =========================================================
   CORE LOGIC
========================================================= */
function initGame() {
  $('btn-load').disabled = !localStorage.getItem('poke_save');
}

function startGame(mode) {
  state.gameMode = mode;
  state.streak = 0;
  state.badges = 0;
  state.inventory.balls = CONSTANTS.START_BALLS;
  state.inventory.pots = CONSTANTS.START_POTS;
  state.activeIdx = 0;
  
  // Starter Logic
  let keys;
  if (mode === 'nuzlocke') {
    keys = Object.keys(POKEMON_SPECIES); // Any pokemon
  } else {
    keys = Object.keys(POKEMON_SPECIES).filter(k => POKEMON_SPECIES[k].tier === 1); 
    if (keys.length === 0) keys = Object.keys(POKEMON_SPECIES);
  }
  
  const randomStarter = keys[Math.floor(Math.random() * keys.length)];
  state.team = [new Pokemon(randomStarter, 5, mode === 'nuzlocke')]; 
  
  $('start-buttons').style.display = 'none';
  $('game-title').classList.add('hidden-title');
  $('mode-display').innerText = mode === 'nuzlocke' ? '‚ò†Ô∏è Nuzlocke' : 'Normal';
  
  $('combat-log').innerHTML = mode === 'nuzlocke' 
    ? "üíÄ Modo Nuzlocke iniciado. ¬°Si mueren, no vuelven!" 
    : "Bienvenido a Kanto Rogue."; 
  
  closeSwitchMenu(); 
  turnLock = false; 
  startBattle();
}

function getTeamAverageLevel() {
  if (state.team.length === 0) return 5;
  const total = state.team.reduce((sum, p) => sum + p.level, 0);
  return Math.floor(total / state.team.length);
}

// 2. Sustituye el inicio de tu funci√≥n startBattle por este bloque:
function startBattle() {
  // Clear temporary states
  state.team.forEach(p => {
      p.resetStages();
      if(p.hp > 0) p.status = null;
  });

  // Background logic (sin cambios)
  const bgs = ['bg-forest', 'bg-cave', 'bg-ocean', 'bg-night', 'bg-volcano'];
  const newBg = bgs[Math.floor(Math.random() * bgs.length)];
  $('battle-scene').className = newBg;

  // --- NUEVA L√ìGICA DE GENERACI√ìN DE OPONENTE ---
  const avgLevel = getTeamAverageLevel();
  let targetLevel;
  
  // C√°lculo de nivel del rival (ligeramente ajustado para variedad)
  if (avgLevel < 15) targetLevel = Math.max(2, avgLevel - 2 + Math.floor(Math.random() * 4)); 
  else if (avgLevel < 30) targetLevel = avgLevel + Math.floor(Math.random() * 3); 
  else targetLevel = avgLevel + Math.floor(Math.random() * 5);

  // Determinar el Tier m√°ximo permitido para este nivel
  const currentTier = getTierFromLevel(targetLevel);

  // Filtramos: Solo aparecen Pok√©mon cuyo spawnTier sea menor o igual al Tier actual.
  // Esto evita que salga un Legendario (Tier 5) si est√°s en nivel 5 (Tier 1),
  // pero permite que salga un Rattata (Tier 1) aunque est√©s en nivel 50.
  let validKeys = Object.keys(POKEMON_SPECIES).filter(key => {
    const pData = POKEMON_SPECIES[key];
    // Si no tiene spawnTier definido, asumimos 1 por seguridad
    const pTier = pData.spawnTier || 1; 
    return pTier <= currentTier;
  });

  // Fallback por si el filtro vac√≠a la lista (no deber√≠a pasar si configuras bien el JS)
  if (validKeys.length === 0) validKeys = Object.keys(POKEMON_SPECIES);

  const pIdx = Math.floor(Math.random() * validKeys.length);
  opponent = new Pokemon(validKeys[pIdx], targetLevel, state.gameMode === 'nuzlocke');
  
  // ... resto de la funci√≥n startBattle (logs, renderAll, etc.) ...
  
  const shinyText = opponent.isShiny ? '‚ú® ' : '';
  log(`‚ö†Ô∏è ¬°Un ${shinyText}<b>${opponent.name}</b> Nvl ${opponent.level} (Tier ${currentTier}) salvaje apareci√≥!`);
  
  turnLock = false; 
  renderAll();
}

function renderAll() {
  const player = state.team[state.activeIdx];
  // Safe check if activeIdx is -1 or out of bounds (Nuzlocke death handling)
  if(!player && state.team.length > 0 && state.activeIdx >= 0) {
    state.activeIdx = 0;
  }
  const currentP = state.team[state.activeIdx];
  
  if(!currentP) return;

  const renderBox = (mon, id, isPlayer) => {
    const hpPct = (mon.hp / mon.maxHp) * 100;
    const color = hpPct > 50 ? '#4caf50' : hpPct > 20 ? '#ffeb3b' : '#f44336';
    const container = $(id);
    const shinyMark = mon.isShiny ? '<span style="color:gold; text-shadow:0 0 5px orange">‚ú®</span> ' : '';
    
    let xpHTML = '';
    if (isPlayer) {
      const xpPct = (mon.xp / mon.xpToNext) * 100;
      xpHTML = `<div class="xp-container"><div class="xp-fill" style="width:${xpPct}%"></div></div>`;
    }

    const statusHTML = mon.status ? `<span class="status-tag status-${mon.status}">${mon.status}</span>` : '';

    container.innerHTML = `
      <div class="poke-name"><span>${shinyMark}${mon.name}</span> <span class="poke-lvl">Nv${mon.level}</span></div>
      <div class="hp-container">
        <div class="hp-fill" style="width:${hpPct}%; background:${color}"></div>
      </div>
      ${xpHTML}
      <div class="hp-text">${statusHTML}${mon.hp}/${mon.maxHp}</div>
    `;
  };

  renderBox(currentP, 'player-box', true);
  renderBox(opponent, 'opponent-box', false);

  const fetchSprite = async (mon, slot, back) => {
    const slug = SLUG_MAP[mon.name] || mon.name.toLowerCase();
    const uniqueId = `${mon.name}-${mon.isShiny ? 'shiny' : 'norm'}-${back?'back':'front'}`;
    const currentImg = $(slot).querySelector('img');

    if(currentImg && currentImg.dataset.uid === uniqueId) return;

    try {
      const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${slug}`);
      const data = await res.json();
      const anim = data.sprites.versions['generation-v']['black-white'].animated;
      let src;
      
      if (mon.isShiny) {
         src = back ? (anim.back_shiny || data.sprites.back_shiny) : (anim.front_shiny || data.sprites.front_shiny);
      } else {
         src = back ? (anim.back_default || data.sprites.back_default) : (anim.front_default || data.sprites.front_default);
      }
      if (!src) src = back ? data.sprites.back_default : data.sprites.front_default;

      $(slot).innerHTML = `<img src="${src}" class="sprite-img" data-uid="${uniqueId}">`;
    } catch(e) {
      $(slot).innerHTML = `<div style="font-size:3rem;">?</div>`;
    }
  };

  fetchSprite(currentP, 'player-sprite-slot', true);
  fetchSprite(opponent, 'opponent-sprite-slot', false);

  $('balls-val').innerText = state.inventory.balls;
  $('pots-val').innerText = state.inventory.pots;
  $('streak-val').innerText = state.streak;
  $('badges-val').innerText = state.badges;

  const movesHTML = currentP.moves.map(mKey => {
    const m = MOVES[mKey];
    if(!m) return '';
    const catShort = m.cat === 'Esp' ? 'Esp' : 'F√≠s';
    return `
    <button class="btn-move type-${m.tipo}" onclick="doTurn('${mKey}')" ${turnLock?'disabled':''}>
      ${m.nombre}<br><small>${m.tipo} / ${m.poder} / ${catShort}</small>
    </button>
  `}).join('');
  $('move-controls').innerHTML = movesHTML;
  
  $('btn-capture').disabled = turnLock || state.inventory.balls <= 0;
  $('btn-potion').disabled = turnLock || state.inventory.pots <= 0 || currentP.hp >= currentP.maxHp;
  $('btn-switch').disabled = turnLock || state.team.filter(p=>p.hp>0).length <= 1;
}

/* =========================================================
   BATTLE LOGIC
========================================================= */
async function executeMove(attacker, defender, move, isPlayer) {
  if(attacker.hp <= 0) return; // Dead check

  const atkSlot = isPlayer ? 'player-sprite-slot' : 'opponent-sprite-slot';
  const defSlot = isPlayer ? 'opponent-sprite-slot' : 'player-sprite-slot';
  const atkZone = isPlayer ? 'zone-player' : 'zone-opponent';
  const defZone = isPlayer ? 'zone-opponent' : 'zone-player';

  // Status Check (Start of Move)
  if (attacker.status === 'FRZ') {
    if(Math.random() < 0.2) {
      attacker.status = null;
      log(`${isPlayer?'ü§†':'üòà'} ¬°${attacker.name} se descongel√≥!`);
    } else {
      log(`‚ùÑÔ∏è ${attacker.name} est√° congelado y no ataca.`);
      return;
    }
  }
  if (attacker.status === 'SLP') {
    if(Math.random() < 0.33) {
      attacker.status = null;
      log(`${isPlayer?'ü§†':'üòà'} ¬°${attacker.name} se despert√≥!`);
    } else {
      log(`üí§ ${attacker.name} duerme profundamente.`);
      return;
    }
  }
  if (attacker.status === 'PAR' && Math.random() < 0.25) {
    log(`‚ö° ${attacker.name} est√° paralizado y no puede moverse.`);
    return;
  }

  if(!move) {
     log(`${isPlayer ? 'üëä' : 'üîª'} ${attacker.name} falla su ataque.`);
     return;
  }

  log(`${isPlayer ? 'üëä' : 'üîª'} ${attacker.name} usa <b>${move.nombre}</b>!`);
  await animateAttack(atkSlot, move.tipo);
  
  // Non-damaging moves (Status only) handling could go here, but for now we assume all have Power except 0
  if (move.poder > 0 || move.nombre === 'Inversi√≥n' || move.nombre === 'Furia Drag√≥n') {
    await shootProjectile(move.tipo, atkZone, defZone);
    const dmg = calcDamage(attacker, defender, move);
    spawnParticles(move.tipo, $(defSlot));

    if (dmg.mult === 0) {
        log(`üö´ ¬°No afecta a ${defender.name}!`);
    } else {
        if(dmg.mult > 1) log(`‚ö° ¬°Es s√∫per efectivo!`);
        if(dmg.mult < 1) log(`üõ°Ô∏è No es muy efectivo...`);
        
        await animateDamage(defSlot);
        defender.hp = Math.max(0, defender.hp - dmg.amount);
    }
  }

  // Effects (Buffs/Debuffs/Status)
  if (defender.hp > 0 && move.effect) {
      if (Math.random() < (move.chance || 1.0)) {
          applyEffect(attacker, defender, move.effect);
      }
  }
}

function applyEffect(attacker, defender, effect) {
    // Stat Modifiers
    if (effect === 'SPD_DOWN') { applyStatChange(defender, 'spe', -1, 'Velocidad'); }
    else if (effect === 'DEF_DOWN') { applyStatChange(defender, 'def', -1, 'Defensa'); }
    else if (effect === 'ATK_UP') { applyStatChange(attacker, 'atk', 1, 'Ataque'); }
    else if (effect === 'DEF_UP') { applyStatChange(attacker, 'def', 1, 'Defensa'); }
    else if (effect === 'ACC_DOWN') { log(`üëÅÔ∏è Precisi√≥n de ${defender.name} baj√≥.`); } // Simplified
    else if (effect === 'ALL_UP') {
        ['atk','def','spa','spd','spe'].forEach(s => attacker.stages[s] = Math.min(6, attacker.stages[s]+1));
        log(`üåü ¬°Todas las estad√≠sticas de ${attacker.name} subieron!`);
    }
    // Status Conditions
    else if (!defender.status) {
        const statuses = ['BRN', 'PSN', 'PAR', 'FRZ', 'SLP', 'CON']; // CON = confusion ignored for simplicity in DB usually
        if (statuses.includes(effect) && effect !== 'CON' && effect !== 'FLI') {
            defender.status = effect;
            log(`‚ú® ¬°${defender.name} sufri√≥ <b>${effect}</b>!`);
        } else if (effect === 'FLI') {
            // Flinch logic handles in turn order, but since this is execution, FLI applies to NEXT turn if defender hasn't moved.
            // Simplified: FLI only visual here
        }
    }
}

function applyStatChange(mon, stat, change, statName) {
    mon.stages[stat] += change;
    if (mon.stages[stat] > 6) mon.stages[stat] = 6;
    if (mon.stages[stat] < -6) mon.stages[stat] = -6;
    const dir = change > 0 ? 'subi√≥' : 'baj√≥';
    log(`üìâ ${mon.name}: Su ${statName} ${dir}.`);
}


async function runStatusDamage(mon, isPlayer) {
  if (mon.hp <= 0) return;
  if (mon.status === 'BRN' || mon.status === 'PSN') {
    const dmg = Math.floor(mon.maxHp / 8);
    mon.hp = Math.max(0, mon.hp - dmg);
    await animateDamage(isPlayer ? 'player-sprite-slot' : 'opponent-sprite-slot');
    log(`${mon.status === 'BRN' ? 'üî•' : '‚ò†Ô∏è'} ${mon.name} sufre da√±o por ${mon.status}.`);
  }
}

async function doTurn(moveKey) {
  if(turnLock) return;
  turnLock = true;
  
  const player = state.team[state.activeIdx];
  const playerMove = MOVES[moveKey];
  
  // Opponent Choice
  let oppMoveKey = null;
  if(opponent.moves.length > 0) {
    oppMoveKey = opponent.moves[Math.floor(Math.random() * opponent.moves.length)];
  }
  const oppMove = oppMoveKey ? MOVES[oppMoveKey] : null;

  // Determine Order based on Speed Stats
  const pSpeed = player.getStat('spe');
  const oSpeed = opponent.getStat('spe');
  
  let first, second;
  let moveFirst, moveSecond;
  let isPlayerFirst;

  // Quick Attack priority check (simplified)
  const pPrio = (playerMove.nombre === 'Ataque R√°pido' || playerMove.nombre === 'Velocidad Extrema') ? 1 : 0;
  const oPrio = (oppMove && (oppMove.nombre === 'Ataque R√°pido' || oppMove.nombre === 'Velocidad Extrema')) ? 1 : 0;

  if (pPrio > oPrio) {
      isPlayerFirst = true;
  } else if (oPrio > pPrio) {
      isPlayerFirst = false;
  } else {
      if (pSpeed >= oSpeed) {
          if (pSpeed === oSpeed) isPlayerFirst = Math.random() < 0.5;
          else isPlayerFirst = true;
      } else {
          isPlayerFirst = false;
      }
  }

  if (isPlayerFirst) {
      first = player; moveFirst = playerMove;
      second = opponent; moveSecond = oppMove;
  } else {
      first = opponent; moveFirst = oppMove;
      second = player; moveSecond = playerMove;
  }

  renderAll(); // Disable buttons

  // ACTION 1
  await executeMove(first, second, moveFirst, isPlayerFirst);
  renderAll();

  // Check Death 1
  if (second.hp <= 0) {
      await handleDeath(second, !isPlayerFirst);
      return;
  }

  await wait(500);

  // ACTION 2
  await executeMove(second, first, moveSecond, !isPlayerFirst);
  renderAll();

  // Check Death 2
  if (first.hp <= 0) {
      await handleDeath(first, isPlayerFirst);
      return;
  }

  // End Turn Effects
  await runStatusDamage(player, true);
  if (player.hp > 0) await runStatusDamage(opponent, false);
  renderAll();

  if (player.hp <= 0) {
      await handleDeath(player, true);
  } else if (opponent.hp <= 0) {
      await handleDeath(opponent, false);
  } else {
      turnLock = false;
      renderAll();
  }
}

async function handleDeath(mon, isPlayer) {
    log(`‚ò†Ô∏è ¬°${mon.name} se debilit√≥!`);
    if (isPlayer) {
        if (state.gameMode === 'nuzlocke') {
            log(`‚ö∞Ô∏è Nuzlocke: ¬°${mon.name} ha muerto para siempre!`);
            state.team.splice(state.activeIdx, 1);
            state.activeIdx = -1;
        }
        checkDefeat();
    } else {
        await handleWin();
        turnLock = false;
        renderAll();
    }
}

function calcDamage(atkMon, defMon, move) {
  let mult = 1;
  if (TYPE_CHART[move.tipo]) {
    defMon.types.forEach(t => {
      if (TYPE_CHART[move.tipo][t] !== undefined) mult *= TYPE_CHART[move.tipo][t];
    });
  }
  if (mult === 0) return { amount: 0, mult: 0 }; 

  // Determine Stats based on Category (Phys vs Special)
  let aStat, dStat;
  if (move.cat === 'Fis') {
      aStat = atkMon.getStat('atk');
      dStat = defMon.getStat('def');
      // Burn reduces physical damage
      if (atkMon.status === 'BRN') aStat = Math.floor(aStat * 0.5);
  } else {
      aStat = atkMon.getStat('spa');
      dStat = defMon.getStat('spd');
  }

  // Fixed Damage Moves
  if (move.nombre === 'Furia Drag√≥n') return { amount: 40, mult: 1 };
  // Reversal logic skipped for brevity, defaults to standard

  const base = ((2 * atkMon.level / 5 + 2) * move.poder * (aStat / dStat)) / 50 + 2;
  
  // Critical Hit (Random 6.25%)
  let critical = 1;
  if (Math.random() < 0.0625) { critical = 1.5; log('üéØ ¬°Golpe Cr√≠tico!'); }

  // STAB
  let stab = atkMon.types.includes(move.tipo) ? 1.5 : 1;

  const total = Math.floor(base * mult * stab * critical * (Math.random() * 0.15 + 0.85)); 
  return { amount: total, mult: mult };
}

/* =========================================================
   POST-BATTLE
========================================================= */
async function handleWin() {
  log(`üèÜ ¬°Ganaste! ${opponent.name} debilitado.`);
  state.streak++;

  // --- Badge Logic ---
  if (state.streak % 9 === 0) {
      state.badges++;
      log(`üèÖ <b>¬°Has conseguido una Medalla de Gimnasio!</b> (Total: ${state.badges})`);
  }

  // --- Special Event: 8th Badge (Win 72) ---
  if (state.streak === 72) {
      log(`üåü <b>¬°HITO LEGENDARIO!</b> Has conseguido las 8 Medallas.`);
      const rewardMon = state.team[state.activeIdx] || state.team[0];
      if (rewardMon) {
          rewardMon.isShiny = true;
          rewardMon.bonusMultiplier = 1.3; // 30% Boost
          rewardMon.recalcStats();
          rewardMon.hp = rewardMon.maxHp; // Heal as prize
          log(`‚ú®üíé ¬°Tu <b>${rewardMon.name}</b> ahora es Shiny y un 30% m√°s fuerte!`);
          await wait(2000);
      }
  }
  
  const teamSizeBonus = 1 + (state.team.length * 0.15); 
  const baseXP = ((opponent.level * 40) + 100) * CONSTANTS.XP_MULT * teamSizeBonus; 
  const shareXP = Math.floor(baseXP / state.team.length);
  
  // Clear Player Status on Win
  state.team.forEach(p => p.status = null);

  for (let i = 0; i < state.team.length; i++) {
    const member = state.team[i];
    if (member.hp <= 0) continue; 

    let gain = (i === state.activeIdx) ? Math.floor(shareXP * 1.3) : shareXP;
    member.xp += gain;
    
    while (member.xp >= member.xpToNext) {
      member.xp -= member.xpToNext;
      member.level++;
      member.xpToNext = member.level * 60 + 100;
      member.recalcStats(); // Recalc on level up
      member.hp = Math.min(member.hp + 5, member.maxHp); 
      log(`üÜô ¬°${member.name} subi√≥ al Nvl ${member.level}!`);
      await checkEvolutionAndMoves(member);
      member.hp = member.maxHp;
    }
  }

  if(state.streak % CONSTANTS.HEAL_STREAK === 0) {
    state.team.forEach(p => p.hp = p.maxHp);
    state.inventory.balls = Math.min(CONSTANTS.MAX_BALLS, state.inventory.balls + 5);
    state.inventory.pots = Math.min(CONSTANTS.MAX_POTS, state.inventory.pots + 2);
    log(`üè• <b>Centro Pok√©mon:</b> ¬°Equipo curado y objetos repuestos!`);
  }

  await wait(1500);
  startBattle();
}

async function checkEvolutionAndMoves(player) {
  // Evolution Logic
  const evoData = EVOLUTIONS[player.name];
  if(evoData && evoData[player.level]) {
    const result = evoData[player.level];
    if(POKEMON_SPECIES[result]) {
      const oldName = player.name;
      player.name = result;
      // Recalc stats for new species
      player.baseStats = {
          hp: POKEMON_SPECIES[result].hp,
          atk: POKEMON_SPECIES[result].atk,
          def: POKEMON_SPECIES[result].def,
          spa: POKEMON_SPECIES[result].sp_atk,
          spd: POKEMON_SPECIES[result].sp_def,
          spe: POKEMON_SPECIES[result].speed
      };
      player.recalcStats();
      player.hp = player.maxHp;
      log(`‚ú® ¬°Tu ${oldName} evolucion√≥ a <b>${player.name}</b>!`);
      await wait(1000); 
    }
  }

  // Move Logic
  let newMove = null;

  if (state.gameMode === 'nuzlocke') {
    // Learn random move every 10 levels in Nuzlocke
    if (player.level % 10 === 0) {
      const allMoves = Object.keys(MOVES);
      newMove = allMoves[Math.floor(Math.random() * allMoves.length)];
    }
  } else {
    // Normal Mode
    if(evoData && evoData[player.level] && MOVES[evoData[player.level]]) {
      newMove = evoData[player.level];
    }
  }

  if (newMove && !player.moves.includes(newMove)) {
    if (player.moves.length < 4) {
      player.moves.push(newMove);
      log(`üí° ¬°${player.name} aprendi√≥ <b>${newMove}</b>!`);
    } else {
      // Prompt to forget
      await promptForgetMove(player, newMove);
    }
  }
}

function promptForgetMove(player, newMove) {
  return new Promise(resolve => {
    const overlay = $('move-overlay');
    const list = $('move-list');
    const cancelBtn = $('btn-cancel-learn');
    list.innerHTML = '';
    
    // Header
    const title = document.createElement('div');
    title.innerHTML = `<b>${player.name}</b> quiere aprender <b style="color:yellow">${newMove}</b>.`;
    title.style.marginBottom = '10px';
    title.style.textAlign = 'center';
    list.appendChild(title);

    // Current Moves
    player.moves.forEach((mKey, idx) => {
      const m = MOVES[mKey];
      const div = document.createElement('div');
      div.className = 'modal-card';
      div.innerHTML = `<span>${m.nombre}</span> <small>${m.tipo}/${m.poder}</small>`;
      div.onclick = () => {
        player.moves[idx] = newMove;
        log(`üí° ¬°${player.name} olvid√≥ ${m.nombre} y aprendi√≥ <b>${MOVES[newMove].nombre}</b>!`);
        overlay.style.display = 'none';
        resolve();
      };
      list.appendChild(div);
    });

    cancelBtn.onclick = () => {
      log(`‚ùå ${player.name} no aprendi√≥ ${MOVES[newMove].nombre}.`);
      overlay.style.display = 'none';
      resolve();
    }
    
    overlay.style.display = 'flex';
  });
}

function checkDefeat() {
  const alive = state.team.some(p => p.hp > 0);
  if(!alive) {
    log(`üíÄ Game Over. Racha final: ${state.streak} | Medallas: ${state.badges}`);
    $('start-buttons').style.display = 'flex';
    $('btn-normal').innerText = 'Reintentar (Normal)';
    $('btn-nuzlocke').innerText = 'Reintentar (Nuzlocke)';
    turnLock = true; 
    renderAll();
  } else {
    openSwitchMenu(true);
  }
}

/* =========================================================
   ACTIONS
========================================================= */
function usePotion() {
  if (turnLock) return;
  const p = state.team[state.activeIdx];
  if(state.inventory.pots > 0 && p.hp < p.maxHp) {
    turnLock = true;
    state.inventory.pots--;
    const healAmount = Math.floor(p.maxHp * 0.60);
    p.hp = Math.min(p.maxHp, p.hp + healAmount);
    log(`üíä Usaste Poci√≥n. ${p.name} recuper√≥ ${healAmount} PS.`);
    renderAll();
    
    // Potions take a turn, so Opponent attacks freely
    setTimeout(async () => {
      let oppMoveKey = null;
      if(opponent.moves.length > 0) {
        oppMoveKey = opponent.moves[Math.floor(Math.random() * opponent.moves.length)];
      }
      const oppMove = oppMoveKey ? MOVES[oppMoveKey] : null;

      await executeMove(opponent, p, oppMove, false);
      
      // Post-Turn Status Damage
      await runStatusDamage(p, true);
      if(p.hp > 0) await runStatusDamage(opponent, false);
      
      renderAll();

      if(p.hp <= 0) {
        await handleDeath(p, true);
      } else {
         turnLock = false;
         renderAll();
      }
    }, 1000);
  }
}

async function attemptCapture() {
  if(turnLock || state.inventory.balls <= 0) return;
  turnLock = true;
  state.inventory.balls--;
  renderAll();
  
  log(`üé± ¬°Lanzaste una Pok√©ball!`);
  
  const ball = document.createElement('div');
  ball.innerHTML = 'üé±';
  ball.style.position = 'absolute';
  ball.style.left = '20%'; ball.style.bottom = '20%'; ball.style.fontSize = '30px';
  ball.style.transition = 'all 0.5s ease-in';
  ball.style.zIndex = 100;
  $('battle-scene').appendChild(ball);
  
  setTimeout(() => { ball.style.left = '70%'; ball.style.top = '20%'; }, 50);
  
  await wait(600);
  ball.remove();
  
  const hpFactor = (opponent.maxHp - opponent.hp) / opponent.maxHp; 
  const statusBonus = opponent.status ? 0.2 : 0;
  const chance = 0.4 + (hpFactor * 0.5) + statusBonus; 
  
  if(Math.random() < chance) {
    log(`‚≠ê ¬°Capturaste a <b>${opponent.name}</b>!`);
    opponent.xp = 0;
    opponent.xpToNext = opponent.level * 60 + 100;
    opponent.hp = opponent.maxHp; 
    opponent.status = null; 
    opponent.resetStages();

    if (state.team.length < CONSTANTS.MAX_TEAM) {
      state.team.push(opponent);
      await wait(1000);
      startBattle();
    } else {
      openPartyFullMenu(opponent);
    }
  } else {
    log(`üí¢ ¬°${opponent.name} se liber√≥!`);
    
    // Enemy attacks on fail capture
    let oppMoveKey = null;
    if(opponent.moves.length > 0) {
      oppMoveKey = opponent.moves[Math.floor(Math.random() * opponent.moves.length)];
    }
    const oppMove = oppMoveKey ? MOVES[oppMoveKey] : null;

    await executeMove(opponent, state.team[state.activeIdx], oppMove, false);
    
    const p = state.team[state.activeIdx];
    await runStatusDamage(p, true);
    if(p.hp > 0) await runStatusDamage(opponent, false);

    renderAll();
    
    if(p.hp <= 0) {
        await handleDeath(p, true);
    } else {
        turnLock = false;
        renderAll();
    }
  }
}

function openPartyFullMenu(newMon) {
  const overlay = $('party-full-overlay');
  const list = $('party-full-list');
  list.innerHTML = '';
  
  state.team.forEach((p, idx) => {
    const div = document.createElement('div');
    const shiny = p.isShiny ? '‚ú®' : '';
    div.className = 'modal-card';
    div.innerHTML = `<span>${shiny}${p.name} (Nv${p.level})</span> <small>Liberar</small>`;
    div.onclick = async () => {
      log(`üëã Has liberado a ${p.name}. ¬°Bienvenido ${newMon.name}!`);
      state.team[idx] = newMon; // Replace
      overlay.style.display = 'none';
      await wait(1000);
      startBattle();
    };
    list.appendChild(div);
  });

  const btnReleaseNew = $('btn-release-new');
  btnReleaseNew.onclick = async () => {
    log(`üëã Liberaste a ${newMon.name}.`);
    overlay.style.display = 'none';
    await wait(1000);
    startBattle();
  };

  overlay.style.display = 'flex';
}

function openSwitchMenu(forced = false) {
  const overlay = $('switch-overlay');
  const list = $('switch-list');
  list.innerHTML = '';
  
  state.team.forEach((p, idx) => {
    const div = document.createElement('div');
    const fainted = p.hp <= 0;
    const shiny = p.isShiny ? '‚ú®' : '';
    const active = idx === state.activeIdx;
    
    div.className = `modal-card ${fainted ? 'fainted' : ''} ${active ? 'selected' : ''}`;
    div.innerHTML = `
      <span>${shiny}${p.name} (Nv${p.level})</span>
      <b>${p.hp}/${p.maxHp} HP</b>
    `;
    if(!fainted) {
      div.onclick = () => doSwitch(idx, forced);
    }
    list.appendChild(div);
  });
  
  overlay.style.display = 'flex';
  if(forced) $('switch-overlay').querySelector('button').style.display = 'none'; 
  else $('switch-overlay').querySelector('button').style.display = 'block'; 
}

function closeSwitchMenu() {
  $('switch-overlay').style.display = 'none';
}

function doSwitch(idx, forced) {
  // Si elegimos al mismo que ya est√° activo y est√° vivo, solo cerramos
  if(idx === state.activeIdx && state.team[idx].hp > 0) {
    closeSwitchMenu();
    return;
  }
  
  state.activeIdx = idx;
  log(`üîÑ ¬°Adelante <b>${state.team[idx].name}</b>!`);
  closeSwitchMenu();
  renderAll();
  
  if(!forced) {
    turnLock = true;
    renderAll(); // Forzamos render para que se deshabiliten los botones visualmente

    setTimeout(async () => {
      try {
        const p = state.team[state.activeIdx];
        
        // Elecci√≥n de movimiento del rival
        let oppMoveKey = null;
        if(opponent.moves && opponent.moves.length > 0) {
          oppMoveKey = opponent.moves[Math.floor(Math.random() * opponent.moves.length)];
        }
        const oppMove = oppMoveKey ? MOVES[oppMoveKey] : null;
        
        log(`üîª El rival aprovecha el cambio.`);
        await executeMove(opponent, p, oppMove, false);
        
        // Da√±o de estado post-turno (quemadura/veneno) si aplica
        await runStatusDamage(p, true);
        renderAll();

        // Verificamos si muri√≥ tras el golpe
        if(p.hp <= 0) {
          await handleDeath(p, true);
        } else {
          turnLock = false; // <--- Importante: Desbloquear si sobrevive
        }
      } catch (e) {
        console.error("Error durante el cambio:", e);
        turnLock = false; // <--- SEGURIDAD: Si algo falla, desbloqueamos igual
      } finally {
        renderAll();
      }
    }, 1000);
  } else {
    // Cambio forzado (por muerte anterior), no hay turno de castigo
    turnLock = false;
    renderAll();
  }
}

function saveGame() {
  const data = JSON.stringify(state);
  localStorage.setItem('poke_save', data);
  alert('Partida guardada.');
  $('btn-load').disabled = false;
}

function loadGame() {
  const data = localStorage.getItem('poke_save');
  if(data) {
    try {
      const rawState = JSON.parse(data);
      // Rehydrate Class Methods
      state = {
          ...rawState,
          team: rawState.team.map(d => {
              const p = new Pokemon(d.name, d.level);
              Object.assign(p, d);
              return p;
          })
      };
      opponent = new Pokemon(opponent ? opponent.name : 'Rattata', 5); // Dummy rehydrate or restart battle

      if (!state.gameMode) state.gameMode = 'normal';
      if (state.badges === undefined) state.badges = 0;

      $('start-buttons').style.display = 'none';
      $('game-title').classList.add('hidden-title');
      $('mode-display').innerText = state.gameMode === 'nuzlocke' ? '‚ò†Ô∏è Nuzlocke' : 'Normal';
      
      startBattle(); // Restart battle gen to avoid sync issues
    } catch(e) {
      console.error(e);
      alert("Error al cargar partida.");
    }
  }
}
</script>
<script type="module" src="/index.tsx"></script>
</body>
</html>
